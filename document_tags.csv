文档标题,所属项目,文档关键词,文档内容概述


YWFE_公用CDN服务,业务运营项目,技术类文档; cdn; ywwl; 公用库; min; 业务项目,【文档概述】本文档主要阐述了YWFE_公用CDN服务的相关内容，包括：支持 http 及 https 。推荐自适应方式应引用
ES6+,技术平台项目,知识类文档; ES6,【文档概述】本文档描述了ES6+相关内容：ES6+...
FAQ,产品研发项目,知识类文档; FAQ; 登录遥望云,【背景情况】A：登录钉钉，并加入遥望，然后稍等片刻（一般情况每个整点钉钉会同步员工信息到遥望云），就可以正常登录了。
Git代码管理规范,流程优化项目,管理类文档; master; release; 分支; fix; 创建; feat; 分支合并到; 使用,【主要内容】开发日常需求或者修复时，从 master 分支 checkout 创建 feat_* 功能分支 或 fix_ 修复分支进行开发。 发布上线成功后，按照规范更新 CHANGLOG 文档，记录该版本更新内容。 基于 master 分支 创建 tag ，在 发行说明 中填入 该版本的更新内容。 功能分支： feat_ 开头。后面可以是功能名也可以是版本号。 【实施方案】发布时，先将需要发布的功能或修复分支以MR形式合并到 release 。再次过程可进行CR操作。 chore : 改变构建流程、或者增加依赖库、工具等
React Hook,数据分析项目,技术类文档; Hook; const; React; context; state; useState; return; count; 示例; effect; filters; 值得注意的是; class; function; div,"【背景情况】Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。 解决编写和维护成千上万的组件时遇到的各种各样看起来不相关的问题，如在组建之间复用状态逻辑很难，复杂组件变得难以理解，以及难以理解的class。 【项目目标】Context 设计目的是为了共享那些对于一个组件树而言是“全局”的数据，例如当前认证的用户、主题或首选语言，如果对context不是很熟悉可以先了解context再看useContext 【主要内容】4. useEffect( (）=> {}, [AA，BB] ) 由于每次渲染都会调用useEffect 所以如果要进行性能优化可以使用 函数的第二个可选参数，在AA或BB 更改时进行更新。如果你要使用此优化方式，请确保数组中包含了所有外部作用域中会随时间变化并且在 effect 中使用的变量 通过自定义 Hook，可以将组件逻辑提取到可重用的函数中。上述示例为table 提供了网络请求和分页的业务逻辑，通过filters的更改进行新请求以更新table的内容 2.自定义 Hook 必须以 “use” 开头吗？必须如此。这个约定非常重要。不遵循的话，由于无法判断某个函数是否包含对其内部 Hook 的调用，React 将无法自动检查你的 Hook 是否违反了 Hook 的规则。 【实施方案】通过使用这个 Hook，你可以告诉 React 组件需要在渲染后执行某些操作。React 会保存你传递的函数（我们将它称之为 “effect”），并且在执行 DOM 更新之后调用它。在这个 effect 中，我们设置了 document 的 title 属性，也可以执行数据获取或调用其他命令式的 API。 3. 组件内如果有多个effect 按使用顺序依次执行。"
TS汇总文档,知识管理项目,技术类文档; number; string; name; const; let; function; return; Person; type; age; any; class; log; target; console; Bird; new; Animal; param; if; typeof; animal,【项目目标】原理： Duck-Check，只要目标类型中声明的属性变量在源类型中都存在就是兼容的。 当比较函数参数当类型当时候，只有当源函数参数能够赋值给目标函数或者返回来，才能赋值成功。 【主要内容】常数枚举与普通枚举的区别是，它会在编辑阶段被删除，并且不能包含计算成员； 可以把一个联合类型指定一个更具具体多类型 a、 指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候指定类型的一种特性； 泛型在判断兼容性当时候，会先判断具体的类型，然后再进行兼容性判断 【实施方案】！ 非空断言表示告诉 TS，这个属性肯定存在，让后续代码放心执行 c、严格模式，函数执行不了到地方； 实现了声明类型可以不用 指定函数参数类型和返回值类型
Type Script,技术平台项目,技术类文档; number; string; let; name; return; is; function; any; length; type; public; Tom; 类型; Person; age; Animal; result; not; to; value; class; Type,"【背景情况】enum Color {Red, Green, Blue}let c: Color = Color.Green;//默认情况下，从0开始为元素编号。 你也可以手动的指定成员的数值。//例如，我们将上面的例子改成从 1开始编号：enum Color {Red = 1, Green, Blue}let c: Color = Color.Green//或者，全部都采用手动赋值：enum Color {Red = 1, Green = 2, Blue = 4}let c: Color = Color.Green;//枚举类型提供的一个便利是你可以由枚举的值得到它的名字。//例如，我们知道数值为2，但是不确定它映射到Color里的哪个名字，我们可以查找相应的名字：enum Color {Red = 1, Green, Blue}let colorName: string = Color[2];console.log(colorName);  // 显示'Green'因为上面代码里它的值是2 【项目目标】// 函数声明（Function Declaration）function sum(x, y) {    return x + y;}// 函数表达式（Function Expression）let mySum = function (x, y) {    return x + y;};//一个函数有输入和输出，要在 TypeScript 中对其进行约束，需要把输入和输出都考虑到，//其中函数声明的类型定义较简单：function sum(x: number, y: number): number {    return x + y;}//*注意，输入多余的（或者少于要求的）参数，是不被允许的：//如果要我们现在写一个对函数表达式（Function Expression）的定义，可能会写成这样：let mySum = function (x: number, y: number): number {    return x + y;};//如果需要我们手动给 mySum 添加类型，则应该是这样：let mySum: (x: number, y: number) => number = function (x: number, y: number): number {    return x + y;}; //采用函数表达式|接口定义函数的方式时，对等号左侧进行类型限制，//可以保证以后对函数名赋值时保证参数个数、参数类型、返回值类型不变。//前面提到，输入多余的（或者少于要求的）参数，是不允许的。那么如何定义可选的参数呢？//与接口中的可选属性类似，我们用 ? 表示可选的参数：function buildName(firstName: string, lastName?: string) {    if (lastName) {        return firstName + ' ' + lastName;    } else {        return firstName;    }}let tomcat = buildName('Tom', 'Cat');let tom = buildName('Tom'); 【主要内容】增强了编辑器和 IDE 的功能，包括代码补全、接口提示、跳转到定义、代码重构等 TypeScript 拥抱了 ES6 规范，支持 ESNext 草案中处于第三阶状态（Stage 3）的特性 传统的JavaScript程序使用函数和基于原型的继承来创建可重用的组件，但对于熟悉使用面向对象方式的程序员来讲就有些棘手，因为他们用的是基于类的继承并且对象是由类构建出来的。 从ECMAScript 2015，也就是ECMAScript 6开始，JavaScript程序员将能够使用基于类的面向对象的方式。 使用TypeScript，允许开发者现在就使用这些特性，并且编译后的JavaScript可以在所有主流浏览器和平台上运行，而不需要等到下个JavaScript版本。 泛型（Generics）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。 【实施方案】TypeScript像JavaScript一样可以操作数组元素。 有两种方式可以定义数组。 第一种，可以在元素类型后面接上 [] ，表示由此类型元素组成的一个数组： let notSure: any = 666;notSure = ""Semlinker"";notSure = false;any 类型本质上是类型系统的一个逃逸舱。作为开发者，这给了我们很大的自由：TypeScript 允许我们对 any 类型的值执行任何操作，而无需事先执行任何形式的检查。比如：let anyThing: any = 'hello';console.log(anyThing.myName);console.log(anyThing.myName.firstName);可以认为，声明一个变量为任意值之后，对它的任何操作，返回的内容的类型都是任意值。 在面向对象语言中，接口（Interfaces）是一个很重要的概念，它是对行为的抽象，而具体如何行动需要由类（classes）去实现（implement）。 【预期效果】为了让程序有价值，我们需要能够处理最简单的数据单元：数字，字符串，结构体，布尔值等。 TypeScript支持与JavaScript几乎相同的数据类型，此外还提供了实用的枚举类型方便我们使用"
